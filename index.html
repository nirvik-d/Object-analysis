<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="initial-scale=1,maximum-scale=1,user-scalable=no"
    />
    <title>Object Analysis</title>
    <link rel="stylesheet" href="./src/style.css" />

    <!-- Load Calcite components from CDN -->
    <script
      type="module"
      src="https://js.arcgis.com/calcite-components/3.2.1/calcite.esm.js"
    ></script>

    <!-- Load the ArcGIS Maps SDK for JavaScript -->
    <link
      rel="stylesheet"
      href="https://js.arcgis.com/4.33/esri/themes/light/main.css"
    />
    <script src="https://js.arcgis.com/4.33/"></script>

    <!-- Load Map components from CDN-->
    <script
      type="module"
      src="https://js.arcgis.com/4.33/map-components/"
    ></script>
  </head>

  <body>
    <arcgis-scene item-id="d6eefc2b1e984e1eaf1c290588a52c55">
      <arcgis-zoom position="top-left"></arcgis-zoom>
      <arcgis-navigation-toggle position="top-left"></arcgis-navigation-toggle>
      <arcgis-compass position="top-left"> </arcgis-compass>

      <arcgis-placement position="top-right">
        <div id="menu" class="esri-widget" style="display: none">
          <h3>Object Analysis</h3>
          <calcite-action-bar id="action-bar" layout="horizontal" expand-disabled>
          </calcite-action-bar>
          <calcite-label id="promptText">Choose an analysis type.</calcite-label>
          <calcite-label id="selectionPromptText" style="display: none">
            <em> To edit an existing analysis, select it by hovering over and clicking on its manipulator.</em>
          </calcite-label>
          <div id="buttons" style="display: none">
            <calcite-button id="clearButton" appearance="outline-fill" kind="neutral">Clear</calcite-button>
            <calcite-button id="doneButton">Done</calcite-button>
          </div>
        </div>
      </arcgis-placement>
    </arcgis-scene>

    <script type="module" src="./src/main.js"></script>
    <!-- <script type="module">
      const [
        SpatialReference,
        Polygon,
        Point,
        AreaMeasurementAnalysis,
        DirectLineMeasurementAnalysis,
        LineOfSightAnalysis,
        ViewshedAnalysis,
        Viewshed,
        DimensionAnalysis,
        LengthDimension,
        SliceAnalysis,
        SlicePlane,
        promiseUtils,
      ] = await $arcgis.import([
        "@arcgis/core/geometry/SpatialReference.js",
        "@arcgis/core/geometry/Polygon.js",
        "@arcgis/core/geometry/Point.js",
        "@arcgis/core/analysis/AreaMeasurementAnalysis.js",
        "@arcgis/core/analysis/DirectLineMeasurementAnalysis.js",
        "@arcgis/core/analysis/LineOfSightAnalysis.js",
        "@arcgis/core/analysis/ViewshedAnalysis.js",
        "@arcgis/core/analysis/Viewshed.js",
        "@arcgis/core/analysis/DimensionAnalysis.js",
        "@arcgis/core/analysis/LengthDimension.js",
        "@arcgis/core/analysis/SliceAnalysis.js",
        "@arcgis/core/analysis/SlicePlane.js",
        "@arcgis/core/core/promiseUtils.js",
      ]);
      let activeTool;
      let activeActionElement;
      let abortController;
      // Get HTML elements
      const viewElement = document.querySelector("arcgis-scene");
      const menu = document.getElementById("menu");
      const actionBar = document.getElementById("action-bar");
      const promptText = document.getElementById("promptText");
      const selectionPromptText = document.getElementById(
        "selectionPromptText"
      );
      const buttons = document.getElementById("buttons");
      const clearButton = document.getElementById("clearButton");
      const doneButton = document.getElementById("doneButton");
      // Array of all the analysis tools used in the sample.
      const tools = [
        {
          name: "Area measurement",
          icon: "measure-area",
          analysis: createAreaMeasurementAnalysis(),
          analysisView: null,
        },
        {
          name: "Direct line measurement",
          icon: "measure-line",
          analysis: createDirectLineMeasurementAnalysis(),
          analysisView: null,
        },
        {
          name: "Line of sight",
          icon: "line-of-sight",
          analysis: createLineOfSightAnalysis(),
          analysisView: null,
        },
        {
          name: "Viewshed",
          icon: "viewshed",
          analysis: createViewshedAnalysis(),
          analysisView: null,
        },
        {
          name: "Dimension",
          icon: "dimensions",
          analysis: createDimensionAnalysis(),
          analysisView: null,
        },
        {
          name: "Slice",
          icon: "slice",
          analysis: createSliceAnalysis(),
          analysisView: null,
        },
      ];
      /**********************************************
       * Setup the UI/UX and add the programamtically created analysis to the analyses collection.
       *********************************************/
      // Create a UI element with a tooltip for each analysis tool.
      for (const tool of tools) {
        const actionElement = setupActionElement(tool);
        actionBar.appendChild(actionElement);
      }

      // If "Done" is clicked, stop the active tool (if any) and reset the UI.
      doneButton.addEventListener("click", () => {
        stopActiveTool();
      });
      // If "Clear" is clicked, remove existing analysis from the view (if any) and update the UI.
      clearButton.addEventListener("click", () => {
        clearAnalysis(activeTool.analysis);
        selectionPromptText.style.display = "none";
        clearButton.style.display = "none";
      });
      // If Esc is pressed, stop the active tool (if any) and reset the UI.
      viewElement.addEventListener("arcgisViewKeyDown", (event) => {
        if (event.detail.key === "Escape") {
          stopActiveTool();
        }
      });

      // Wait for the view to be ready.
      await viewElement.viewOnReady();
      // Add the analysis tools to it and save their analysisViews for later access.
      // Promise.all() returns all whenAnalysisView Promises as one single Promise.
      await Promise.all([
        tools.map(async (tool) => {
          viewElement.analyses.add(tool.analysis);
          tool.analysisView = await viewElement.whenAnalysisView(tool.analysis);
        }),
      ]);
      // Make the menu visible.
      menu.style.display = "block";

      /**********************************************
       * Functions for creating and updating the UI/UX.
       *********************************************/
      function setupActionElement(tool) {
        const actionElement = document.createElement("calcite-action");
        actionElement.icon = tool.icon;
        actionElement.addEventListener("click", () =>
          onActionElementClick(tool, actionElement)
        );
        const actionTooltip = setupActionTooltip(tool, actionElement);
        actionElement.appendChild(actionTooltip);
        return actionElement;
      }

      function setupActionTooltip(tool, referenceActionElement) {
        const tooltip = document.createElement("calcite-tooltip");
        tooltip.placement = "top";
        tooltip.referenceElement = referenceActionElement;
        tooltip.innerHTML = tool.name;
        tooltip.closeOnClick = true;
        return tooltip;
      }

      function onActionElementClick(tool, actionElement) {
        if (!actionElement.active) {
          // If a non-active tool was picked, stop the previous active tool (if any) and reset the UI.
          stopActiveTool();
          // Set the new active tool and start placing the analysis.
          activeTool = tool;
          placeContinuous();
          // Update menu and show the button controls.
          updateUI(actionElement);
        } else {
          // If the previously active tool is picked, stop it and reset the UI.
          stopActiveTool();
        }
      }

      function stopActiveTool() {
        // Stop any placing, make the analysis not interactive, and null the active tool reference.
        if (activeTool) {
          abortController?.abort();
          activeTool.analysisView.interactive = false;
          activeTool = null;
        }
        // Reset the action bar and update the UI.
        for (const action of actionBar.children) {
          action.removeAttribute("active");
        }
        updateUI(activeActionElement);
      }

      function updateUI(actionElement) {
        // If the function was triggered by a click on an actionElement,
        // update the action bar, buttons, and prompt text.
        if (actionElement) {
          // If an already active actionElement was clicked, hide the buttons and reset the UI.
          // Otherwise show UI for the new tool.
          const resetUI = actionElement === activeActionElement ? true : false;
          buttons.style.display = resetUI ? "none" : "flex";
          actionElement.active = resetUI ? false : true;
          promptText.innerHTML = resetUI
            ? "Choose an analysis type."
            : "Click in view to start placing " +
              analysisTypeToName(activeTool?.analysis.type) +
              " analysis.";
          // Update currently active action element for future reference.
          activeActionElement = resetUI ? null : actionElement;
        }
        // Only if the active tool has any analysis present, show the "Clear" button
        // and an extra hint about selection for viewsheds and dimensions.
        const activeAnalysisPresent = checkIfAnalysisPresent();
        if (activeAnalysisPresent) {
          clearButton.style.display = "flex";
          selectionPromptText.style.display =
            activeTool?.analysis.type === "viewshed" ||
            activeTool?.analysis.type === "dimension"
              ? "block"
              : "none";
        } else {
          clearButton.style.display = "none";
          selectionPromptText.style.display = "none";
        }
      }

      function checkIfAnalysisPresent() {
        const analysis = activeTool?.analysis;
        if (!analysis) {
          return false;
        }
        switch (analysis.type) {
          case "direct-line-measurement":
            return analysis.startPoint !== null && analysis.endPoint !== null;
          case "area-measurement":
            return analysis.geometry !== null;
          case "line-of-sight":
            return analysis.observer !== null;
          case "slice":
            return analysis.shape !== null;
          case "viewshed":
            return analysis.viewsheds?.length > 0;
          case "dimension":
            return analysis.dimensions?.length > 0;
          default:
            return false;
        }
      }

      /**********************************************
       * Functions for placing and clearing the analyses.
       *********************************************/
      async function placeContinuous() {
        // Stop any previous placing and create a new controller.
        abortController?.abort();
        abortController = new AbortController();
        // Get a reference to the signal for the new placement operation.
        const { signal } = abortController;
        try {
          // After one analysis is placed, call the place() method again.
          // This is done until the placing is aborted.
          while (!signal.aborted) {
            await activeTool.analysisView.place({
              signal,
            });
            // Update the UI e.g. show "Clear" button afer an anaysis was added to an empty analysis object.
            updateUI();
          }
        } catch (error) {
          // Avoid logging the abort errors.
          throwIfNotAbortError(error);
        } finally {
          // Remove the controller if this was the last started placement.
          if (abortController?.signal === signal) {
            abortController = null;
          }
        }
      }

      function clearAnalysis(analysis) {
        if (!analysis) {
          return;
        }
        switch (analysis.type) {
          case "direct-line-measurement":
            analysis.startPoint = null;
            analysis.endPoint = null;
            break;
          case "area-measurement":
            analysis.geometry = null;
            break;
          case "line-of-sight":
            analysis.observer = null;
            analysis.targets = [];
            break;
          case "slice":
            analysis.shape = null;
            break;
          case "viewshed":
            analysis.viewsheds = [];
            break;
          case "dimension":
            analysis.dimensions = [];
            break;
        }
      }
      /**********************************************
       * Functions to create the analyses.
       *********************************************/
      function createDirectLineMeasurementAnalysis() {
        return new DirectLineMeasurementAnalysis({
          startPoint: newPoint(-8238827, 4971466, 3),
          endPoint: newPoint(-8238819, 4971537, 3),
        });
      }

      function createAreaMeasurementAnalysis() {
        const roofPolygon = new Polygon({
          rings: [
            [
              [-8238931, 4971381, 50],
              [-8238926, 4971426, 50],
              [-8238835, 4971415, 50],
              [-8238841, 4971369, 50],
              [-8238931, 4971381, 50],
            ],
          ],
          spatialReference: SpatialReference.WebMercator,
        });
        return new AreaMeasurementAnalysis({
          geometry: roofPolygon,
        });
      }

      function createSliceAnalysis() {
        return new SliceAnalysis({
          shape: new SlicePlane({
            position: newPoint(-8238840, 4971700, 21),
            tilt: 0,
            width: 70,
            height: 100,
            heading: 278,
          }),
        });
      }

      function createLineOfSightAnalysis() {
        return new LineOfSightAnalysis({
          observer: {
            position: newPoint(-8238825, 4971538, 48),
          },
          targets: [
            {
              position: newPoint(-8238903, 4971649, 2),
            },
            {
              position: newPoint(-8238866, 4971629, 19),
            },
            {
              position: newPoint(-8238825, 4971880, 2),
            },
            {
              position: newPoint(-8238791, 4971784, 2),
            },
          ],
        });
      }

      function createViewshedAnalysis() {
        return new ViewshedAnalysis({
          viewsheds: [
            new Viewshed({
              observer: newPoint(-8238868, 4971525, 48),
              heading: -80,
              tilt: 75,
              farDistance: 120,
              horizontalFieldOfView: 55,
              verticalFieldOfView: 55,
            }),
          ],
        });
      }

      function createDimensionAnalysis() {
        return new DimensionAnalysis({
          dimensions: [
            new LengthDimension({
              startPoint: newPoint(-8238805.863420386, 4971633.739526394, 3.8),
              endPoint: newPoint(-8238815.848786024, 4971563.1027141735, 3.8),
              offset: 17,
              orientation: 270,
              measureType: "direct",
            }),
            new LengthDimension({
              startPoint: newPoint(-8238805.863404014, 4971633.739529291, 3.8),
              endPoint: newPoint(-8238805.863404014, 4971633.739529291, 22.8),
              offset: 15,
              orientation: 8,
              measureType: "direct",
            }),
          ],
        });
      }
      /**********************************************
       * General helper functions.
       *********************************************/
      // Convenience function to have all points in the same spatial reference
      function newPoint(x, y, z) {
        return new Point({
          x,
          y,
          z,
          spatialReference: SpatialReference.WebMercator,
        });
      }
      // Only log errors that are not abort errors.
      function throwIfNotAbortError(error) {
        if (!promiseUtils.isAbortError(error)) {
          throw error;
        }
      }
      // Remove kebab-case.
      function analysisTypeToName(text) {
        return text.replace(/-/g, " ");
      }
    </script> -->
  </body>
</html>
